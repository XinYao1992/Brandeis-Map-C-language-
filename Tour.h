/*check if certain vertex is marked in Vnew[]*/
int isInVnew(int Vnew[], int vertex_index){
	if(Vnew[vertex_index] == -1){
		return 0; //if not exists, 0;
	}else{
		return 1;
	}	
}

/*check if all vertices are marked in Vnew[]*/
int isVnewFull(int Vnew[]){
	int i = 0;
	for(i = 0; i < nV; i ++){
		if(Vnew[i] == -1){
			return 0;//if not full, 0;
		}
	}
	return 1;
}

/*depth first search function*/
void DFS(int vertex_index, struct vertexArray array, int Enew[]){
	struct edge *edge_of_vertex;
	edge_of_vertex = array.VertexArray[vertex_index];
	while(edge_of_vertex != NULL ){
		if(Enew[edge_of_vertex->index] == 1){
			PrintLeg(edge_of_vertex->index);
			DFS(Eend[edge_of_vertex->index], array, Enew);
			int i = 0;
			for(i = 0; i < nE; i ++){
				if(Eend[i] == vertex_index && Estart[i] == Eend[edge_of_vertex->index]){
					PrintLeg(i);
					break;
				}
			}	
		}
		edge_of_vertex = edge_of_vertex->next;
	}
}

int vertex_order[MaxEdge], vertex_p;

/*find the traversal sequence*/
void traversalSequence(int vertex_index, struct vertexArray array, int Enew[]){
	struct edge *edge_of_vertex;
	edge_of_vertex = array.VertexArray[vertex_index];
	while(edge_of_vertex != NULL ){
		if(Enew[edge_of_vertex->index] == 1){
			vertex_order[vertex_p++] = Estart[edge_of_vertex->index];
			traversalSequence(Eend[edge_of_vertex->index], array, Enew);
			int i = 0;
			for(i = 0; i < nE; i ++){
				if(Eend[i] == vertex_index && Estart[i] == Eend[edge_of_vertex->index]){
					vertex_order[vertex_p++] = Estart[i];
					break;
				}
			}	
		}
		edge_of_vertex = edge_of_vertex->next;
	}
}

/*used in fnction "shortCutSearch"*/
double costOfTwoVertices(int vertex_order[], int start, int finish, int skip_times){
	int cost = 0;
	int i;
	int j;
	for(i = 0; i < nE; i ++){
		if(vertex_order[i] == start && vertex_order[i + skip_times + 1] == finish){
			int index = i;
			while(index < (i + skip_times + 1)){
				for(j = 0; j < nE; j ++){
					if(Estart[j] == vertex_order[index] && Eend[j] == vertex_order[index+1]){
						cost += EdgeCost(j);
						break;
					}
				}
				index ++;
			}
		}
		break;
	}
	return cost;
}

/*used in fnction "shortCutSearch"*/
void printEdgesBetweenTwoVertices(int vertex_order[], int start, int finish, int skip_times){
	int i;
	int j;
	for(i = 0; i < nE; i ++){
		if(vertex_order[i] == start && vertex_order[i + skip_times + 1] == finish){
			int index = i;
			while(index < (i + skip_times + 1)){
				for(j = 0; j < nE; j ++){
					if(Estart[j] == vertex_order[index] && Eend[j] == vertex_order[index+1]){
						PrintLeg(j);
						break;
					}
				}
				index ++;
			}
		}
		break;
	}
	
}

/*used in fnction "shortCutSearch"*/
int isFlagFull(int flag[]){
	int i;
	for(i = 0; i < nV; i ++){
		if(flag[i] != 1){
			return 0;
		}
	}
	return 1;
}

/*new search function for shortcutting, using the minimum spanning tree generated by Prim algorithm*/
void shortCutSearch(int vertex_index, struct vertexArray array, int vertex_order[], int flag[], int Begin){
	int current;//current vertex
	int next;//next vertex
	int skip_times = 0;
	int vertex_order_index = 0;//point to the vertex after "next".
	int i;
	int j;
	int ifEdgeFound = 0;
	
	current = vertex_order[vertex_order_index];
	next = vertex_order[++vertex_order_index];
	while(next != -1 && !isFlagFull(flag)){
		ifEdgeFound = 0;
		for(i = 0; i < nE; i ++){
			if(Estart[i] == current && Eend[i] == next && flag[next] != 1){
				ifEdgeFound = 1;
				flag[next] = 1;
				if(skip_times > 0){
					/*to check if the new edge we found is shorter than before*/
					if(EdgeCost(i) <= costOfTwoVertices(vertex_order, current, next, skip_times)){
						PrintLeg(i);
						current = next;
						next = vertex_order[++vertex_order_index];
						skip_times = 0;
						break;
					}else{
						printEdgesBetweenTwoVertices(vertex_order, current, next, skip_times);
						current = next;
						next = vertex_order[++vertex_order_index];
						skip_times = 0;
						break;
					}
				}else{
					PrintLeg(i);
					current = next;
					next = vertex_order[++vertex_order_index];
					skip_times = 0;
					break;
				}
			}else if(Estart[i] == current && Eend[i] == next && flag[next] == 1){
				ifEdgeFound = 1;
				skip_times ++;
				next = vertex_order[++vertex_order_index];
				break;
			}
		}//end for loop
		if(ifEdgeFound == 0 && flag[next] != 1){
			flag[next] = 1;
			printEdgesBetweenTwoVertices(vertex_order, current, next, skip_times);
			current = next;
			next = vertex_order[++vertex_order_index];
			skip_times = 0;
		}else if(ifEdgeFound == 0 && flag[next] == 1){
			skip_times ++;
			next = vertex_order[++vertex_order_index];
		}
	
	}
	
	
}



void Tour () {
	int vertex_num = nV;
	int edge_num = MaxEdge;//nE records directed edge.
	int Vnew[vertex_num];//store the vertex that has been traversed.
	int Enew[edge_num];//store the edge that has been recorded.
	vertex_p = 0;
	
	/*initial adjacency list*/
	buildAdjacencyList();
	
	/*instantiate heap*/
	/*this time, each node of heap contains: 1.index of edge; 2.its cost*/
	heap *tourHeap;
	tourHeap = (struct heap*)malloc(sizeof(struct heap));
	tourHeap->node_array = (struct node *)malloc(sizeof(struct node) * MaxEdge);//after struct, need to malloc
	tourHeap->node_num = 0;
	
		
	/*find the edges connected to "Begin", store each edge node into heap*/
	struct edge *edge_of_vertex;
	edge_of_vertex = (struct edge *)malloc(sizeof(struct edge));
	edge_of_vertex = array.VertexArray[Begin];
	while(edge_of_vertex != NULL){
		int edge_index = edge_of_vertex->index;
		node *new_edge;
		new_edge = (struct node *)malloc(sizeof(struct node));//after struct, need to malloc
		new_edge->index = edge_index;
		new_edge->distance = EdgeCost(edge_index);
		insertHeap(tourHeap, new_edge);
		/*get next edge node*/
		edge_of_vertex = edge_of_vertex->next;
	}

	/*initial Vnew[] and Enew[], -1 for inexistence*/
	int i = 0;
	for(i = 0; i < vertex_num; i ++){
		Vnew[i] = -1;
	}
	for(i = 0; i < edge_num; i ++){
		Enew[i] = -1;
	}
	
	/*in the beginning, we put "Begin" vertex into Vnew[]*/
	Vnew[0] = 1;
	Vnew[1] = 1;
	Vnew[2] = 1;
	Vnew[3] = 1;
	Vnew[4] = 1;
	Vnew[Begin] = 1;
	 
	/*generate minimum spanning tree*/ 
	while(!isVnewFull(Vnew)){//!isVnewFull(Vnew)
		/*the node from the heap*/
		node *returnNode;
		returnNode = (struct node *)malloc(sizeof(struct node));//after struct, need to malloc
		*returnNode = deleteHeap(tourHeap);//first returned node is not source
		int edge_index = returnNode->index;
		if(!isInVnew(Vnew, Eend[edge_index]) && isInVnew(Vnew, Estart[edge_index])){
			/*find a new vertex and an edge, and store it into the Vnew and Enew*/
			int end_vertex = Eend[edge_index];
			Vnew[end_vertex] = 1;
			/*find an edge, and store it into Enew*/
			Enew[edge_index] = 1;
			/*find the edges started from the vertex we just found, then add into heap*/
			struct edge *edge_of_vertex;
			edge_of_vertex = (struct edge *)malloc(sizeof(struct edge));
			edge_of_vertex = array.VertexArray[end_vertex];
			while(edge_of_vertex != NULL){
				int edge = edge_of_vertex->index;
				int end = Eend[edge];
				if(isInVnew(Vnew, end)){
					/*get next edge node*/
					edge_of_vertex = edge_of_vertex->next;
				}else{
					/*ignore the edges from 0 ~ 19*/
					
						node *new_edge;
						new_edge = (struct node *)malloc(sizeof(struct node));//after struct, need to malloc
						new_edge->index = edge;
						new_edge->distance = EdgeCost(edge);
						insertHeap(tourHeap, new_edge);
					
					/*get next edge node*/
					edge_of_vertex = edge_of_vertex->next;
				}
			}
		}
		
	}
	
	/*print edges of mminimum spanning tree in pre-order*/ 
	for(i = 0; i < edge_num; i ++){
		if(Enew[i] == 1){
			//printf("edge index:%d\n", i);
		}
	}
	
	/*depth first search algorithm*/
	/*print the edge which starts from "Begin", traverse all forward and backward edges and then return to "Begin", no short cut.*/
	DFS(Begin, array, Enew);
	
	/*find the vertex's order whenn doing traverse, store the order in an array. e.g., vertex_order[0] stores the first vertex index*/
	/*this part is for shortcutting*/
	for(i = 0; i < nE; i ++){/*initial vertex_order[]*/
		vertex_order[i] = -1;
	}
	traversalSequence(Begin, array, Enew);
	for(i = 0; i < nE; i ++){
		if(vertex_order[i] == -1){
			vertex_order[i] = Begin;
			break;
		}
	}
	
	/*find the shortcutting*/
	int flag[nV];//1 means the vertex is marked, -1 otherwise.
	for(i = 0; i < nV; i ++){
		flag[i] = -1;
	}
	flag[Begin] = 1;
	flag[0] = 1;
	//shortCutSearch(Begin, array, vertex_order, flag, Begin);
	
	
	
	
}
